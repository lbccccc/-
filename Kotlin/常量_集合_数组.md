集合
Kotlin 和 Java 一样有三种集合类型：List、Set 和 Map，它们的含义分别如下：

List 以固定顺序存储一组元素，元素可以重复。
Set 存储一组互不相等的元素，通常没有固定顺序。
Map 存储 键-值 对的数据集合，键互不相等，但不同的键可以对应相同的值。
从 Java 到 Kotlin，这三种集合类型的使用有哪些变化呢？我们依次看看。

List

Java 中创建一个列表：

☕️
List<String> strList = new ArrayList<>();
strList.add("a");
strList.add("b");
strList.add("c"); // 👈 添加元素繁琐
Java
Kotlin 中创建一个列表：

🏝️            
val strList = listOf("a", "b", "c")
Kotlin
首先能看到的是 Kotlin 中创建一个 List 特别的简单，有点像创建数组的代码。而且 Kotlin 中的 List 多了一个特性：支持 covariant（协变）。也就是说，可以把子类的 List 赋值给父类的 List 变量：

Kotlin：

🏝️
val strs: List<String> = listOf("a", "b", "c")
                👆
val anys: List<Any> = strs // success
               👆
Kotlin
而这在 Java 中是会报错的：

☕️
List<String> strList = new ArrayList<>();
       👆
List<Object> objList = strList; // 👈 compile error: incompatible types
      👆  
Java
对于协变的支持与否，List 和数组刚好反过来了。关于协变，这里只需结合例子简单了解下，后面的文章会对它展开讨论。

和数组的区别

Kotlin 中数组和 MutableList 的 API 是非常像的，主要的区别是数组的元素个数不能变。那在什么时候用数组呢？

这个问题在 Java 中就存在了，数组和 List 的功能类似，List 的功能更多一些，直觉上应该用 List 。但数组也不是没有优势，基本类型 (int[]、float[]) 的数组不用自动装箱，性能好一点。

在 Kotlin 中也是同样的道理，在一些性能需求比较苛刻的场景，并且元素类型是基本类型时，用数组好一点。不过这里要注意一点，Kotlin 中要用专门的基本类型数组类 (IntArray FloatArray LongArray) 才可以免于装箱。也就是说元素不是基本类型时，相比 Array，用 List 更方便些。

Set

Java 中创建一个 Set：

☕️
Set<String> strSet = new HashSet<>();
strSet.add("a");
strSet.add("b");
strSet.add("c");
Java
Kotlin 中创建相同的 Set：

🏝️           
val strSet = setOf("a", "b", "c")
Kotlin
和 List 类似，Set 同样具有 covariant（协变）特性。

Map

Java 中创建一个 Map：

☕️
Map<String, Integer> map = new HashMap<>();
map.put("key1", 1);
map.put("key2", 2);
map.put("key3", 3);
map.put("key4", 3);
Java
Kotlin 中创建一个 Map：

🏝️         
val map = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key4" to 3)
Kotlin
和上面两种集合类型相似创建代码很简洁。mapOf 的每个参数表示一个键值对，to 表示将「键」和「值」关联，这个叫做「中缀表达式」，这里先不展开，后面的文章会做介绍。

取值和修改

Kotlin 中的 Map 除了和 Java 一样可以使用 get() 根据键获取对应的值，还可以使用方括号的方式获取：

🏝️
                 👇
val value1 = map.get("key1")
               👇
val value2 = map["key2"]
Kotlin
类似的，Kotlin 中也可以用方括号的方式改变 Map 中键对应的值：

🏝️       
              👇
val map = mutableMapOf("key1" to 1, "key2" to 2)
    👇
map.put("key1", 2)
   👇
map["key1"] = 2    
Kotlin
这里用到了「操作符重载」的知识，实现了和数组一样的「Positional Access Operations」，关于这个概念这里先不展开，后面会讲到。

可变集合/不可变集合

上面修改 Map 值的例子中，创建函数用的是 mutableMapOf() 而不是 mapOf()，因为只有 mutableMapOf() 创建的 Map 才可以修改。Kotlin 中集合分为两种类型：只读的和可变的。这里的只读有两层意思：

集合的 size 不可变
集合中的元素值不可变
以下是三种集合类型创建不可变和可变实例的例子：

listOf() 创建不可变的 List，mutableListOf() 创建可变的 List。
setOf() 创建不可变的 Set，mutableSetOf() 创建可变的 Set。
mapOf() 创建不可变的 Map，mutableMapOf() 创建可变的 Map。
可以看到，有 mutable 前缀的函数创建的是可变的集合，没有 mutbale 前缀的创建的是不可变的集合，不过不可变的可以通过 toMutable*() 系函数转换成可变的集合：

🏝️
val strList = listOf("a", "b", "c")
            👇
strList.toMutableList()
val strSet = setOf("a", "b", "c")
            👇
strSet.toMutableSet()
val map = mapOf("key1" to 1, "key2" to 2, "key3" to 3, "key4" to 3)
         👇
map.toMutableMap()
Kotlin
然后就可以对集合进行修改了，这里有一点需要注意下：

toMutable*() 返回的是一个新建的集合，原有的集合还是不可变的，所以只能对函数返回的集合修改。
Sequence
除了集合 Kotlin 还引入了一个新的容器类型 Sequence，它和 Iterable 一样用来遍历一组数据并可以对每个元素进行特定的处理，先来看看如何创建一个 Sequence。

创建
类似 listOf() ，使用一组元素创建：

🏝️
sequenceOf("a", "b", "c")
Kotlin
使用 Iterable 创建：

🏝️
val list = listOf("a", "b", "c")
list.asSequence()
Kotlin
这里的 List 实现了 Iterable 接口。

使用 lambda 表达式创建：

🏝️                          // 👇 第一个元素
val sequence = generateSequence(0) { it + 1 }
                                  // 👆 lambda 表达式，负责生成第二个及以后的元素，it 表示前一个元素
Kotlin
2020 7.20 17:27
