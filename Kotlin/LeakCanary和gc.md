通过间接或者直接与gcRoot联系起来的不会被gc回收

gcRoot三类

- 运行中的线程
- 静态对象
- 本地代码的引用




# LeakCanary 源码解析

##  什么是内存泄露？

- 传统定义的内存泄露：申请的内存忘记释放了。 

- Android （或 JVM）的内存泄露：短⽣命周期的对象被⻓⽣命周期的对象持有， 从⽽导致短⽣命周 期的对象不能被释放 

## 垃圾回收机制 

垃圾回收机制分为「引⽤计数法」和「可达性分析法」： 

- 引⽤计数法」 Python , Object-C , Swift 

  ⽤⼀个计数器记录⼀个对象被引⽤的次数，如果引⽤的次数被减少到 0 那么说 明这个对象是垃圾 对象。 都是引⽤计数（引⽤计数有循环引⽤的问题） 

- 「可达性分析法」 Java Jvm 通过⼀些 GC Roots 向下搜索，如果可以被 Gc Roots 引⽤到的对象，说明 这个对象不是垃圾 对象，反之这个对象就算互相引⽤了也是垃圾对象 

  那些对象 会被作为 GC Roots 呢？ 

  - 在线程栈中的局部变量，也就是正在被调⽤的⽅法，它⾥⾯的参数和局部变量 
  - 存活的线程对象 
  - JNI 的引⽤ 
  - Class 对象，因为 Android 加载 Class 后不会卸载 Class 
  - 引⽤类型的静态变量 



## 内存泄露的问题

内存泄漏并不会⻢上把程序搞挂掉。但是随着应⽤的使⽤，不能回收的垃圾对象会 越来越多，就导致了 可⽤的内存越来越少，到最后应⽤就有可能在任何位置抛出 OutOfMemoryError ，这种情况下，每次 OOM 错误堆栈都不同，就很难定位问 题。 

## 监控 Activity 和 Fragment 原理 

通过注册 Application 和 Fragment 上的⽣命周期回调来完成在 Activity 和 Fragment 销毁的时候开始观察。 

> 1.x 的 LeakCanary 只监控了 support 包和 API 26 以上的 Fragment 。 



## 四⼤引⽤ 

- 强⼀点的引⽤ 强引⽤——不会被垃圾回收 

- 弱⼀点的引⽤ 
  - 弱引⽤——可以通过 get() 获得引⽤对象，会被垃圾回收 
  - 软引⽤——可以通过 get() 获得引⽤对象，内存不⾜会被垃圾回收 
  - 虚引⽤——不能通过 get() 获得引⽤对象，会被垃圾回收

 弱引⽤在引⽤对象被垃圾回收之前，会将引⽤放⼊它关联的队列中。所以可以通 过队列中是否有对 应的引⽤来判断对象是否被垃圾回收了。 

## watch() ⽅法 

原理：就是通过弱引⽤的⽅式来判断队列中是否有弱引⽤来判断对象是否被垃圾回 收了。 

触发 GC 的正确姿势 

通过 dumpHprofData 来获取 hprof ⽂件 

分析会在独⽴进程中进⾏， 

1.x 内部使⽤ haha ， 2.x 内部使⽤ shark 。 

在 1.x 版本中，通过 haha 第三⽅库进⾏堆⽂件分析。 在 2.x 版本中，通过 shark 第三⽅库进⾏堆⽂件分析，内存占⽤⼤幅度减少， 分析速度⼤幅度提⾼。 

## 2.0 不需要主动初始化的原理

 ContentProvider#onCreate 会在 Application#onCreate 之前先执⾏ ， 在这个 onCreate 中就可以进⾏初始化了。 LeakCanary 2.0 利⽤了这个 原理，所 以不需要我们⼿动进⾏初始化
 
 
 
# 网上找的理解
 
 1强引用：在Java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之一。
2软引用：软引用需要用SoftReference类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。
3弱引用：弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。
4虚引用：虚引用需要PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。



![img](https://upload-images.jianshu.io/upload_images/24099992-5772d2b0411f09eb)





一、原理概述

首先，笔者仔细查看了Leakcanary官方的github仓库，最重要的便是对**Leakcanary是如何起作用的**（即原理）这一问题进行了阐述，我自己把它翻译成了易于理解的文字，主要分为如下7个步骤：

- 1、RefWatcher.watch()创建了一个KeyedWeakReference用于去观察对象。
- 2、然后，在后台线程中，它会检测引用是否被清除了，并且是否没有触发GC。
- 3、如果引用仍然没有被清除，那么它将会把堆栈信息保存在文件系统中的.hprof文件里。
- 4、HeapAnalyzerService被开启在一个独立的进程中，并且HeapAnalyzer使用了HAHA开源库解析了指定时刻的堆栈快照文件heap dump。
- 5、从heap dump中，HeapAnalyzer根据一个独特的引用key找到了KeyedWeakReference，并且定位了泄露的引用。
- 6、HeapAnalyzer为了确定是否有泄露，计算了到GC Roots的最短强引用路径，然后建立了导致泄露的链式引用。
- 7、这个结果被传回到app进程中的DisplayLeakService，然后一个泄露通知便展现出来了。

官方的原理简单来解释就是这样的：**在一个Activity执行完onDestroy()之后，将它放入WeakReference中，然后将这个WeakReference类型的Activity对象与ReferenceQueque关联。这时再从ReferenceQueque中查看是否有没有该对象，如果没有，执行gc，再次查看，还是没有的话则判断发生内存泄露了。最后用HAHA这个开源库去分析dump之后的heap内存。**
 
 
 
 
 
 2020 9.24 10.36
