###  通过字节码来学习

1. 内部类 内部类会持有外部类的原因是在内部类中⽤⼀个成员变量记录了外部类对象 在 Kotlin 中，如果在内部类中没有使⽤到外部类，那么不会持有外部类 
2.  泛型 Java 的泛型擦除并不是将所有泛型信息全部都擦除了，会将类上和⽅法上声 明的泛型信息保 存在字节码中的 Signature 属性中，这也是反射能够获取 泛型的原因。但是在⽅法中的泛型 信息是完全擦除了 
3. synchronized 关键字 synchronized 会在⽅法调⽤前后通过 monitor 来进⼊和退出锁









JVM 运⾏时数据区 

- 被所有线程共享的 
  - 堆 
  - ⽅法区 
  - 运⾏时常量池 

- 每个线程私有的 
  - 本地⽅法栈 
  - 虚拟机栈 
  - 程序计数器 

- 虚拟机栈中的栈帧 
  - 局部变量表 
  - 操作数栈 
  - 动态连接 
  - 返回地址 

- 对象在堆中： 
  - 对象头 
    - MarkWord 
    - 类型指针 
    - 数组⻓度（对象是数组时）
  - 具体数据
  - 对⻬填充

## 垃圾回收

-  JVM 堆的结构划分 

  - 新⽣代 

    - eden (80%) 
    - from (10%) 
    - To (10%)

  - ⽼年代

    对象会在新⽣代的 eden 区域中创建（⼤对象会直接进⼊⽼年代），第⼀次 eden 区满了以后进⾏ minor GC 将存货对象 age + 1，然后放⼊ from 区域，将 Eden 区域内存清空。 以后每次 minor GC 都将 eden 和 from 中的存活对象 age + 1 ，然后放⼊ to 区 域，然后将 to 区 域和 from 区域互相调换。 在 age 达到⼀定值时会移动到⽼年代 在 minor GC 时，存活对象⼤于 to 区域，那么会直接进⼊⽼年代

- 垃圾回收算法 

  - 标记-清除算法 （会产⽣空闲内存碎⽚)
  - 标记-整理算法（防⽌产⽣内存碎⽚）
  -  复制算法（效率最⾼，但是内存利⽤率低）

> JVM 中新⽣代使⽤复制算法，⽼年代使⽤标记整理算法




2020 9.24  16.56
