## onNewIntent与启动模式

前提:ActivityA已经启动过,处于当前应用的Activity任务栈中; 

当ActivityA的LaunchMode为Standard时：

由于每次启动ActivityA都是启动新的实例，和原来启动的没关系，所以不会调用原来ActivityA的onNewIntent方法

当ActivityA的LaunchMode为SingleTop时：

如果ActivityA在栈顶,且现在要再启动ActivityA，这时会调用onNewIntent()方法 ，生命周期顺序为：

onCreate--->onStart--->onResume---onPause--->onNewIntent--->onResume

当ActivityA的LaunchMode为SingleInstance,SingleTask：

如果ActivityA已经在任务栈中，再次启动ActivityA，那么此时会调用onNewIntent()方法，生命周期调用顺序为：

onPause--->跳转其它页面--->onCreate--->onStart--->onResume---onPause--->跳转A--->onNewIntent--->onRestart--->onStart--->onResume

**因此：onNewIntent在情况1下调用，在情况2不调用**

**更准确的说法是，只对SingleTop(且位于栈顶)，SingleTask和SingleInstance(且已经在任务栈中存在实例)的情况下，再次启动它们时才会调用，即只对startActivity有效，对仅仅从后台切换到前台而不再次启动的情形，不会触发onNewIntent**



## 弹出 Dialog 对生命周期有什么影响

我们知道，生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以不会对生命周期有任何影响。

如果是启动一个 Theme 为 Dialog 的 Activity , 则生命周期为： A.onPause -> B.onCreate -> B.onStart -> B.onResume 注意这边没有前一个 Activity 不会回调 onStop，因为只有在 Activity 切到后台不可见才会回调 onStop；而弹出 Dialog 主题的 Activity 时前一个页面还是可见的，只是失去了焦点而已所以仅有 onPause 回调。





## Activity 在 onResume 之后才显示的原因是什么

虽然我们设置 Activity 的布局一般都是在 onCreate 方法里调用 setContentView 。里面是直接调用 window 的 setContentView，创建一个 DecorView 用来包住我们创建的布局，然而这一步只是加载好了布局，生成一个 ViewTree 。WindowManager 的 addView 方法最终将 DecorView 添加到 WMS ，实现绘制到屏幕、接收触屏事件。综上，在 onResume 回调之后，会创建一个 ViewRootImpl ，有了它之后应用端就可以和 WMS 进行双向调用了。同时也是通过 ViewRootImpl 从 WMS 申请 Surface 来绘制 ViewTree 。



**onNewIntent(Intent intent)方法**

当我们在activity的启动模式中设置为栈内唯一时，也就是android:launchMode=”singleTask”或android:launchMode=”signleTop”时，会用到这个方法。

比如说在一个应用中A activity 跳转至 B activity 在跳转至 C activity 然后C做了一定的操作之后再返回A 界面。这样在A activity的启动模式设置为singleTask后。C界面跳转至A界面时，就会去判断栈内是否有改Activity实例，如果有就直接执行A界面的onNewIntent()方法，我们就可以把逻辑处理放在改生命周期方法中，如果没有就会走Activity的oncrate方法去创建实例。

在比如说我们做了一个应用。没个界面都有一个返回至主界面操作的按钮。这样的话我们就给主界面的启动模式设置为android:launchMode=”singleTask”。当用户在任何界面点击返回至主界面的按钮时，就正常的使用Intent去跳转。只不过在栈内存在主界面的实例时，不会执行onCrate()方法而是执行的onNewIntent()方法。这时我们就把操作逻辑放在此处。

需要注意的是，在onCrate()方法中最好也写一份操作逻辑，因为当系统内存不足时，我们的主界面实例已经被系统回收了，还是会去执行onCrate()方法的。



大家遇到一个应用的Activity供多种方式调用启动的情况，多个调用希望只有一个Activity的实例存在，这就需要Activity的onNewIntent(Intent intent)方法了。只要在Activity中加入自己的onNewIntent(intent)的实现加上Manifest中对Activity设置lanuchMode=“singleTask”就可以。

​    onNewIntent（）非常好用，Activity第一启动的时候执行onCreate()---->onStart()---->onResume()等后续生命周期函数，也就时说第一次启动Activity并不会执行到onNewIntent(). 而后面如果再有想启动Activity的时候，那就是执行onNewIntent()---->onResart()------>onStart()----->onResume().  如果android系统由于内存不足把已存在Activity释放掉了，那么再次调用的时候会重新启动Activity即执行onCreate()---->onStart()---->onResume()等。

   当调用到onNewIntent(intent)的时候，需要在onNewIntent() 中使用setIntent(intent)赋值给Activity的Intent.否则，后续的getIntent()都是得到老的Intent。

2020 10.4 22.34
