https://www.jianshu.com/p/8a58d8335270

## 2.4 Java内存模型中的重排序

- 在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。

### 2.4.1 重排序类型

![img](https:////upload-images.jianshu.io/upload_images/4222138-0531c2c33ca2f3d2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1025/format/webp)

- 1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-LevelParallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。



Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序，从而让程序按我们预想的流程去执行。
 1、保证特定操作的执行顺序。
 2、影响某些数据（或则是某条指令的执行结果）的内存可见性。



### volatile变量自身具有下列特性：

- 可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
- 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。

volatile写的内存语义如下：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。

volatile读的内存语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。



### synchronized的实现原理

使用monitorenter和monitorexit指令实现的：

- monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处
- 每个monitorenter必须有对应的monitorexit与之配对
- 任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态


2020 10.4 23.41
