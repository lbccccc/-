https://blog.csdn.net/zhangting19921121/article/details/104673519?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.add_param_isCf


只有长度N >= 7的时候，红黑树的平均查找长度lgN才会小于链表的平均查找长度N/2，这个可以画函数图来确定，lgN 与N/2的交点处N约为6.64。
为什么设置为8而不是7呢？一个原因是为了防止出现频繁的链表与树的转换，当大于8的时候链表转红黑树，小于6的时候红黑树转链表，中间这段作为缓冲。
## 二叉查找树

**二叉查找树（BST）具备什么特性呢？**

1.左子树上所有结点的值均小于或等于它的根结点的值。

2.右子树上所有结点的值均大于或等于它的根结点的值。

3.左、右子树也分别为二叉排序树。

## 红黑树的性质

红黑树（Red Black Tree）是一种自平衡的二叉查找树，除了符合二叉查找树的特性外还具有以下特性：

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子都是黑色的空节点（NIL节点）。

 注： 叶子与叶子节点是两个概念，叶子不是一个节点，可以理解为没有数值的空节点，也就是图中的NIL。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。
红黑树能够以O(log n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。
当然，还有一些更好的，但实现起来更复杂的数据结构能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。





# 优点

相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据。如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的。





2020 10.5 20.56
