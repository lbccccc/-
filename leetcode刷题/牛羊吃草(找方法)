牛牛和羊羊都很喜欢青草。今天他们决定玩青草游戏。
最初有一个装有n份青草的箱子,牛牛和羊羊依次进行,牛牛先开始。在每个回合中,每个玩家必须吃一些箱子中的青草,所吃的青草份数必须是4的x次幂,比如1,4,16,64等等。不能在箱子中吃到有效份数青草的玩家落败。假定牛牛和羊羊都是按照最佳方法进行游戏,请输出胜利者的名字。

时间限制：1秒；空间限制：32768K

输入描述:

输入包括t+1行。
第一行包括一个整数t(1 ≤ t ≤ 100),表示情况数.
接下来t行每行一个n(1 ≤ n ≤ 10^9),表示青草份数
输出描述:

对于每一个n,如果牛牛胜利输出"niu",如果羊羊胜利输出"yang"。
示例1
输入

3
1
2
3
输出

niu
yang
niu


解题思路
这类题一般可以考虑递归求解，但是由于本题要考虑的依赖状态太多， f(n) 依赖于f(n)自身、f(n-1)、f(n-4)、f(n-16)、f(n-64)……，递归思路行不通。只能用非递归的思路，通过归纳找规律解题。

找规律发现，可以按照青草数N除以5取模分类：

当N%5==1或N%5==4，牛牛都可以把草的数量变为0，而羊羊面对0的草堆必输，因此牛牛必赢。 
当N%5==0，牛牛只能吃1或4，因此牛牛吃完后，剩余的草量只能为1或4，对于两种情况，羊羊都能在吃完之后使剩余数量为0。正好与第一种情况互补，因此羊羊必赢。
当N%5==2，牛牛只能把草的数量变为1或者3（2-4+5），此时他当然只能选择3，如此羊羊可以选择吃1个草来使得N==2，因此羊羊可以做到：使牛牛始终面临的草量都为2，其中特殊情况即2，因此羊羊必赢。
当N%5==3，牛牛可以吃1个草，使得羊羊面临N%5==2的情况，正好与第三种情况互补，因此牛牛必赢。
综上： 
当N%5==1或4或3时，牛牛必赢； N%5==0或2时，羊羊必赢。

for _ in range(int(input())):
    print("niu" if int(input())%5 in [1,3,4] else 'yang')
    
    
    
    
    2020 10.15 23.51
